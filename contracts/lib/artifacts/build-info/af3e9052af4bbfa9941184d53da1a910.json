{
	"id": "af3e9052af4bbfa9941184d53da1a910",
	"_format": "hh-sol-build-info-1",
	"solcVersion": "0.8.19",
	"solcLongVersion": "0.8.19+commit.7dd6d404",
	"input": {
		"language": "Solidity",
		"sources": {
			"contracts/lib/UniswapV3PriceCalculator.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"https://github.com/Uniswap/v3-core/blob/0.8/contracts/libraries/TickMath.sol\";\n\nimport '@uniswap/v3-core/contracts/libraries/FixedPoint96.sol';\n\n\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            require(denominator > 0);\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        require(denominator > prod1);\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0]\n        // Compute remainder using mulmod\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n        }\n        // Subtract 256 bit number from 512 bit number\n        assembly {\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator\n        // Compute largest power of two divisor of denominator.\n        // Always >= 1.\n        uint256 twos = (~denominator + 1) & denominator;\n\n        // Divide denominator by power of two\n        assembly {\n            denominator := div(denominator, twos)\n        }\n\n        // Divide [prod1 prod0] by the factors of two\n        assembly {\n            prod0 := div(prod0, twos)\n        }\n        // Shift in bits from prod1 into prod0. For this we need\n        // to flip `twos` such that it is 2**256 / twos.\n        // If twos is zero, then it becomes one\n        assembly {\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        prod0 |= prod1 * twos;\n\n        // Invert denominator mod 2**256\n        // Now that denominator is an odd number, it has an inverse\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n        // Compute the inverse by starting with a seed that is correct\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\n        uint256 inv = (3 * denominator) ^ 2;\n        // Now use Newton-Raphson iteration to improve the precision.\n        // Thanks to Hensel's lifting lemma, this also works in modular\n        // arithmetic, doubling the correct bits in each step.\n        inv *= 2 - denominator * inv; // inverse mod 2**8\n        inv *= 2 - denominator * inv; // inverse mod 2**16\n        inv *= 2 - denominator * inv; // inverse mod 2**32\n        inv *= 2 - denominator * inv; // inverse mod 2**64\n        inv *= 2 - denominator * inv; // inverse mod 2**128\n        inv *= 2 - denominator * inv; // inverse mod 2**256\n\n        // Because the division is now exact we can divide by multiplying\n        // with the modular inverse of denominator. This will give us the\n        // correct result modulo 2**256. Since the precoditions guarantee\n        // that the outcome is less than 2**256, this is the final result.\n        // We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inv;\n        return result;\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n}\n\nlibrary UniswapV3PriceCalculator {\n    using FullMath for uint256;\n\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n\n\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        uint256 z = (x + 1) / 2;\n        uint256 y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n        return y;\n    }\n\n    // Function to calculate the sqrtPriceX96 from a given price\n    function calculateSqrtPriceX96(uint256 price) internal pure returns (uint160 sqrtPriceX96) {\n        sqrtPriceX96 = uint160(sqrt(price) * 2 ** 96);\n    }\n\n    \n\n\n    // Function to convert sqrtPriceX96 to a uint256 value\n    function sqrtPriceX96ToUint(uint160 sqrtPriceX96, uint8 decimalsToken0)  internal pure returns (uint256){\n        uint256 numerator1 = uint256(sqrtPriceX96) * uint256(sqrtPriceX96);\n        uint256 numerator2 = 10**decimalsToken0;\n        return FullMath.mulDiv(numerator1, numerator2, 1 << 192);\n    }\n\n\n    // Function to get the sqrtPriceX96 at a given tick\n    function getSqrtPriceAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        sqrtPriceX96 = TickMath.getSqrtRatioAtTick(tick);\n    }\n  \n   \n\n    // Function to get the tick at a given sqrtPriceX96\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);\n    }\n\n    function calculateTicksFromPriceRange(\n        uint160 minPrice,\n        uint160 maxPrice\n    ) internal pure returns (int24 tickLower, int24 tickUpper) {\n        // Ensure minPrice and maxPrice are valid and minPrice < maxPrice\n        require(\n            minPrice >= TickMath.MIN_SQRT_RATIO &&\n            maxPrice <= TickMath.MAX_SQRT_RATIO &&\n            minPrice < maxPrice,\n            \"Invalid price range\"\n        );\n\n        // Calculate the tickLower and tickUpper using TickMath.getTickAtSqrtRatio\n        tickLower = TickMath.getTickAtSqrtRatio(minPrice);\n        tickUpper = TickMath.getTickAtSqrtRatio(maxPrice);\n\n        // Ensure tickLower and tickUpper are within the valid range\n        require(\n            tickLower < tickUpper && tickLower >= TickMath.MIN_TICK && tickUpper <= TickMath.MAX_TICK,\n            \"Ticks out of range\"\n        );\n    }\n\n}\n\n"
			},
			"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol": {
				"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.4.0;\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n    uint8 internal constant RESOLUTION = 96;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n"
			},
			"https://github.com/Uniswap/v3-core/blob/0.8/contracts/libraries/TickMath.sol": {
				"content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    error T();\n    error R();\n\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        unchecked {\n            uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n            if (absTick > uint256(int256(MAX_TICK))) revert T();\n\n            uint256 ratio = absTick & 0x1 != 0\n                ? 0xfffcb933bd6fad37aa2d162d1a594001\n                : 0x100000000000000000000000000000000;\n            if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n            if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n            if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n            if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n            if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n            if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n            if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n            if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n            if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n            if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n            if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n            if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n            if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n            if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n            if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n            if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n            if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n            if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n            if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n            if (tick > 0) ratio = type(uint256).max / ratio;\n\n            // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n            // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n            // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n            sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n        }\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        unchecked {\n            // second inequality must be < because the price can never reach the price at the max tick\n            if (!(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO)) revert R();\n            uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n            uint256 r = ratio;\n            uint256 msb = 0;\n\n            assembly {\n                let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(5, gt(r, 0xFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(4, gt(r, 0xFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(3, gt(r, 0xFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(2, gt(r, 0xF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(1, gt(r, 0x3))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := gt(r, 0x1)\n                msb := or(msb, f)\n            }\n\n            if (msb >= 128) r = ratio >> (msb - 127);\n            else r = ratio << (127 - msb);\n\n            int256 log_2 = (int256(msb) - 128) << 64;\n\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(63, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(62, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(61, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(60, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(59, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(58, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(57, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(56, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(55, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(54, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(53, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(52, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(51, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(50, f))\n            }\n\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n            tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n        }\n    }\n}\n"
			}
		},
		"settings": {
			"optimizer": {
				"enabled": true,
				"runs": 200
			},
			"outputSelection": {
				"*": {
					"*": [
						"*"
					]
				}
			},
			"viaIR": true
		}
	},
	"output": {
		"contracts": {
			"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol": {
				"FixedPoint96": {
					"abi": [],
					"devdoc": {
						"details": "Used in SqrtPriceMath.sol",
						"kind": "dev",
						"methods": {},
						"title": "FixedPoint96",
						"version": 1
					},
					"evm": {
						"assembly": "    /* \"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol\":245:379  library FixedPoint96 {... */\n  0x80\n  dup1\n  0x40\n  mstore\n  jumpi(tag_1, callvalue)\n  dataSize(sub_0)\n  swap1\n  dup2\n  dataOffset(sub_0)\n  dup3\n  codecopy\n  address\n  dup2\n  assignImmutable(\"0xcd5a02d485074f67d63783a7acdae578618045c23ccf47fa4e3f1a01c11714ad\")\n  return\ntag_1:\n  0x00\n  dup1\n  revert\nstop\n\nsub_0: assembly {\n        /* \"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol\":245:379  library FixedPoint96 {... */\n      0x00\n      dup1\n      revert\n\n    auxdata: 0xa2646970667358221220625aefb7e4dc1627fb9aa0f7023858d5739732f109483313e18b0f7c4743632364736f6c63430008130033\n}\n",
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "60808060405234601757603a9081601d823930815050f35b600080fdfe600080fdfea2646970667358221220625aefb7e4dc1627fb9aa0f7023858d5739732f109483313e18b0f7c4743632364736f6c63430008130033",
							"opcodes": "PUSH1 0x80 DUP1 PUSH1 0x40 MSTORE CALLVALUE PUSH1 0x17 JUMPI PUSH1 0x3A SWAP1 DUP2 PUSH1 0x1D DUP3 CODECOPY ADDRESS DUP2 POP POP RETURN JUMPDEST PUSH1 0x0 DUP1 REVERT INVALID PUSH1 0x0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 PUSH3 0x5AEFB7 0xE4 0xDC AND 0x27 0xFB SWAP11 LOG0 0xF7 MUL CODESIZE PC 0xD5 PUSH20 0x9732F109483313E18B0F7C4743632364736F6C63 NUMBER STOP ADDMOD SGT STOP CALLER ",
							"sourceMap": "245:134:0:-:0;;;;;;;;;;;;;;;;;;;;;"
						},
						"deployedBytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "600080fdfea2646970667358221220625aefb7e4dc1627fb9aa0f7023858d5739732f109483313e18b0f7c4743632364736f6c63430008130033",
							"opcodes": "PUSH1 0x0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 PUSH3 0x5AEFB7 0xE4 0xDC AND 0x27 0xFB SWAP11 LOG0 0xF7 MUL CODESIZE PC 0xD5 PUSH20 0x9732F109483313E18B0F7C4743632364736F6C63 NUMBER STOP ADDMOD SGT STOP CALLER ",
							"sourceMap": "245:134:0:-:0;;"
						},
						"gasEstimates": {
							"creation": {
								"codeDepositCost": "11600",
								"executionCost": "infinite",
								"totalCost": "infinite"
							}
						},
						"legacyAssembly": {
							".code": [
								{
									"begin": 245,
									"end": 379,
									"name": "PUSH",
									"source": 0,
									"value": "80"
								},
								{
									"begin": 245,
									"end": 379,
									"name": "DUP1",
									"source": 0
								},
								{
									"begin": 245,
									"end": 379,
									"name": "PUSH",
									"source": 0,
									"value": "40"
								},
								{
									"begin": 245,
									"end": 379,
									"name": "MSTORE",
									"source": 0
								},
								{
									"begin": 245,
									"end": 379,
									"name": "CALLVALUE",
									"source": 0
								},
								{
									"begin": 245,
									"end": 379,
									"name": "PUSH [tag]",
									"source": 0,
									"value": "1"
								},
								{
									"begin": 245,
									"end": 379,
									"name": "JUMPI",
									"source": 0
								},
								{
									"begin": 245,
									"end": 379,
									"name": "PUSH #[$]",
									"source": 0,
									"value": "0000000000000000000000000000000000000000000000000000000000000000"
								},
								{
									"begin": 245,
									"end": 379,
									"name": "SWAP1",
									"source": 0
								},
								{
									"begin": 245,
									"end": 379,
									"name": "DUP2",
									"source": 0
								},
								{
									"begin": 245,
									"end": 379,
									"name": "PUSH [$]",
									"source": 0,
									"value": "0000000000000000000000000000000000000000000000000000000000000000"
								},
								{
									"begin": 245,
									"end": 379,
									"name": "DUP3",
									"source": 0
								},
								{
									"begin": 245,
									"end": 379,
									"name": "CODECOPY",
									"source": 0
								},
								{
									"begin": 245,
									"end": 379,
									"name": "ADDRESS",
									"source": 0
								},
								{
									"begin": 245,
									"end": 379,
									"name": "DUP2",
									"source": 0
								},
								{
									"begin": 245,
									"end": 379,
									"name": "ASSIGNIMMUTABLE",
									"source": 0,
									"value": "library_deploy_address"
								},
								{
									"begin": 245,
									"end": 379,
									"name": "RETURN",
									"source": 0
								},
								{
									"begin": 245,
									"end": 379,
									"name": "tag",
									"source": 0,
									"value": "1"
								},
								{
									"begin": 245,
									"end": 379,
									"name": "JUMPDEST",
									"source": 0
								},
								{
									"begin": 245,
									"end": 379,
									"name": "PUSH",
									"source": 0,
									"value": "0"
								},
								{
									"begin": 245,
									"end": 379,
									"name": "DUP1",
									"source": 0
								},
								{
									"begin": 245,
									"end": 379,
									"name": "REVERT",
									"source": 0
								}
							],
							".data": {
								"0": {
									".auxdata": "a2646970667358221220625aefb7e4dc1627fb9aa0f7023858d5739732f109483313e18b0f7c4743632364736f6c63430008130033",
									".code": [
										{
											"begin": 245,
											"end": 379,
											"name": "PUSH",
											"source": 0,
											"value": "0"
										},
										{
											"begin": 245,
											"end": 379,
											"name": "DUP1",
											"source": 0
										},
										{
											"begin": 245,
											"end": 379,
											"name": "REVERT",
											"source": 0
										}
									]
								}
							},
							"sourceList": [
								"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol",
								"contracts/lib/UniswapV3PriceCalculator.sol",
								"https://github.com/Uniswap/v3-core/blob/0.8/contracts/libraries/TickMath.sol",
								"#utility.yul"
							]
						},
						"methodIdentifiers": {}
					},
					"ewasm": {
						"wasm": ""
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Used in SqrtPriceMath.sol\",\"kind\":\"dev\",\"methods\":{},\"title\":\"FixedPoint96\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol\":\"FixedPoint96\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol\":{\"keccak256\":\"0x0ba8a9b95a956a4050749c0158e928398c447c91469682ca8a7cc7e77a7fe032\",\"license\":\"GPL-2.0-or-later\",\"urls\":[\"bzz-raw://186d3b528866065a5856f96d2aeec698efa99f8da913e9adf34f8cc296cc993d\",\"dweb:/ipfs/QmUAiMvtAQp8c9dy57bqJYzG7hkb1uChiPaQmt264skoqP\"]}},\"version\":1}",
					"storageLayout": {
						"storage": [],
						"types": null
					},
					"userdoc": {
						"kind": "user",
						"methods": {},
						"notice": "A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)",
						"version": 1
					}
				}
			},
			"contracts/lib/UniswapV3PriceCalculator.sol": {
				"FullMath": {
					"abi": [],
					"devdoc": {
						"kind": "dev",
						"methods": {},
						"version": 1
					},
					"evm": {
						"assembly": "    /* \"contracts/lib/UniswapV3PriceCalculator.sol\":211:4980  library FullMath {... */\n  0x80\n  dup1\n  0x40\n  mstore\n  jumpi(tag_1, callvalue)\n  dataSize(sub_0)\n  swap1\n  dup2\n  dataOffset(sub_0)\n  dup3\n  codecopy\n  address\n  dup2\n  assignImmutable(\"0xcd5a02d485074f67d63783a7acdae578618045c23ccf47fa4e3f1a01c11714ad\")\n  return\ntag_1:\n  0x00\n  dup1\n  revert\nstop\n\nsub_0: assembly {\n        /* \"contracts/lib/UniswapV3PriceCalculator.sol\":211:4980  library FullMath {... */\n      0x00\n      dup1\n      revert\n\n    auxdata: 0xa26469706673582212207779c4369bddc196f4f6cc1cd6572d35f7dc42f400a4c006d70baac6907283b964736f6c63430008130033\n}\n",
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "60808060405234601757603a9081601d823930815050f35b600080fdfe600080fdfea26469706673582212207779c4369bddc196f4f6cc1cd6572d35f7dc42f400a4c006d70baac6907283b964736f6c63430008130033",
							"opcodes": "PUSH1 0x80 DUP1 PUSH1 0x40 MSTORE CALLVALUE PUSH1 0x17 JUMPI PUSH1 0x3A SWAP1 DUP2 PUSH1 0x1D DUP3 CODECOPY ADDRESS DUP2 POP POP RETURN JUMPDEST PUSH1 0x0 DUP1 REVERT INVALID PUSH1 0x0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 PUSH24 0x79C4369BDDC196F4F6CC1CD6572D35F7DC42F400A4C006D7 SIGNEXTEND 0xAA 0xC6 SWAP1 PUSH19 0x83B964736F6C63430008130033000000000000 ",
							"sourceMap": "211:4769:1:-:0;;;;;;;;;;;;;;;;;;;;;"
						},
						"deployedBytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "600080fdfea26469706673582212207779c4369bddc196f4f6cc1cd6572d35f7dc42f400a4c006d70baac6907283b964736f6c63430008130033",
							"opcodes": "PUSH1 0x0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 PUSH24 0x79C4369BDDC196F4F6CC1CD6572D35F7DC42F400A4C006D7 SIGNEXTEND 0xAA 0xC6 SWAP1 PUSH19 0x83B964736F6C63430008130033000000000000 ",
							"sourceMap": "211:4769:1:-:0;;"
						},
						"gasEstimates": {
							"creation": {
								"codeDepositCost": "11600",
								"executionCost": "infinite",
								"totalCost": "infinite"
							},
							"internal": {
								"mulDiv(uint256,uint256,uint256)": "infinite",
								"mulDivRoundingUp(uint256,uint256,uint256)": "infinite"
							}
						},
						"legacyAssembly": {
							".code": [
								{
									"begin": 211,
									"end": 4980,
									"name": "PUSH",
									"source": 1,
									"value": "80"
								},
								{
									"begin": 211,
									"end": 4980,
									"name": "DUP1",
									"source": 1
								},
								{
									"begin": 211,
									"end": 4980,
									"name": "PUSH",
									"source": 1,
									"value": "40"
								},
								{
									"begin": 211,
									"end": 4980,
									"name": "MSTORE",
									"source": 1
								},
								{
									"begin": 211,
									"end": 4980,
									"name": "CALLVALUE",
									"source": 1
								},
								{
									"begin": 211,
									"end": 4980,
									"name": "PUSH [tag]",
									"source": 1,
									"value": "1"
								},
								{
									"begin": 211,
									"end": 4980,
									"name": "JUMPI",
									"source": 1
								},
								{
									"begin": 211,
									"end": 4980,
									"name": "PUSH #[$]",
									"source": 1,
									"value": "0000000000000000000000000000000000000000000000000000000000000000"
								},
								{
									"begin": 211,
									"end": 4980,
									"name": "SWAP1",
									"source": 1
								},
								{
									"begin": 211,
									"end": 4980,
									"name": "DUP2",
									"source": 1
								},
								{
									"begin": 211,
									"end": 4980,
									"name": "PUSH [$]",
									"source": 1,
									"value": "0000000000000000000000000000000000000000000000000000000000000000"
								},
								{
									"begin": 211,
									"end": 4980,
									"name": "DUP3",
									"source": 1
								},
								{
									"begin": 211,
									"end": 4980,
									"name": "CODECOPY",
									"source": 1
								},
								{
									"begin": 211,
									"end": 4980,
									"name": "ADDRESS",
									"source": 1
								},
								{
									"begin": 211,
									"end": 4980,
									"name": "DUP2",
									"source": 1
								},
								{
									"begin": 211,
									"end": 4980,
									"name": "ASSIGNIMMUTABLE",
									"source": 1,
									"value": "library_deploy_address"
								},
								{
									"begin": 211,
									"end": 4980,
									"name": "RETURN",
									"source": 1
								},
								{
									"begin": 211,
									"end": 4980,
									"name": "tag",
									"source": 1,
									"value": "1"
								},
								{
									"begin": 211,
									"end": 4980,
									"name": "JUMPDEST",
									"source": 1
								},
								{
									"begin": 211,
									"end": 4980,
									"name": "PUSH",
									"source": 1,
									"value": "0"
								},
								{
									"begin": 211,
									"end": 4980,
									"name": "DUP1",
									"source": 1
								},
								{
									"begin": 211,
									"end": 4980,
									"name": "REVERT",
									"source": 1
								}
							],
							".data": {
								"0": {
									".auxdata": "a26469706673582212207779c4369bddc196f4f6cc1cd6572d35f7dc42f400a4c006d70baac6907283b964736f6c63430008130033",
									".code": [
										{
											"begin": 211,
											"end": 4980,
											"name": "PUSH",
											"source": 1,
											"value": "0"
										},
										{
											"begin": 211,
											"end": 4980,
											"name": "DUP1",
											"source": 1
										},
										{
											"begin": 211,
											"end": 4980,
											"name": "REVERT",
											"source": 1
										}
									]
								}
							},
							"sourceList": [
								"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol",
								"contracts/lib/UniswapV3PriceCalculator.sol",
								"https://github.com/Uniswap/v3-core/blob/0.8/contracts/libraries/TickMath.sol",
								"#utility.yul"
							]
						},
						"methodIdentifiers": {}
					},
					"ewasm": {
						"wasm": ""
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/lib/UniswapV3PriceCalculator.sol\":\"FullMath\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol\":{\"keccak256\":\"0x0ba8a9b95a956a4050749c0158e928398c447c91469682ca8a7cc7e77a7fe032\",\"license\":\"GPL-2.0-or-later\",\"urls\":[\"bzz-raw://186d3b528866065a5856f96d2aeec698efa99f8da913e9adf34f8cc296cc993d\",\"dweb:/ipfs/QmUAiMvtAQp8c9dy57bqJYzG7hkb1uChiPaQmt264skoqP\"]},\"contracts/lib/UniswapV3PriceCalculator.sol\":{\"keccak256\":\"0x50769d29efa35f0db307722bdede1b2c45f0c01277a9cb1255c75962f334baef\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://16042641a7b3401d6205e26581316bc881bc9c6917e93f09fe6c1f6e0a000bb0\",\"dweb:/ipfs/QmZBFVSBjXNC9KuoRz7yfJf6TmgfXEkJPx2fvmgGt2sPSw\"]},\"https://github.com/Uniswap/v3-core/blob/0.8/contracts/libraries/TickMath.sol\":{\"keccak256\":\"0x5c57de03a91cc2ec8939865dbbcb0197bb6c353b711075eefd8e0fca5e102129\",\"license\":\"GPL-2.0-or-later\",\"urls\":[\"bzz-raw://1e994c24fd891ef8a3f5dbf5eba42b34feaf05e0376a29f91322faa18054449c\",\"dweb:/ipfs/QmNdUJGUQxd1dPkMbnA5f5UNqakxRkQE5r7bTZJAuHeapS\"]}},\"version\":1}",
					"storageLayout": {
						"storage": [],
						"types": null
					},
					"userdoc": {
						"kind": "user",
						"methods": {},
						"version": 1
					}
				},
				"UniswapV3PriceCalculator": {
					"abi": [],
					"devdoc": {
						"kind": "dev",
						"methods": {},
						"version": 1
					},
					"evm": {
						"assembly": "    /* \"contracts/lib/UniswapV3PriceCalculator.sol\":4982:7281  library UniswapV3PriceCalculator {... */\n  0x80\n  dup1\n  0x40\n  mstore\n  jumpi(tag_1, callvalue)\n  dataSize(sub_0)\n  swap1\n  dup2\n  dataOffset(sub_0)\n  dup3\n  codecopy\n  address\n  dup2\n  assignImmutable(\"0xcd5a02d485074f67d63783a7acdae578618045c23ccf47fa4e3f1a01c11714ad\")\n  return\ntag_1:\n  0x00\n  dup1\n  revert\nstop\n\nsub_0: assembly {\n        /* \"contracts/lib/UniswapV3PriceCalculator.sol\":4982:7281  library UniswapV3PriceCalculator {... */\n      0x00\n      dup1\n      revert\n\n    auxdata: 0xa26469706673582212208741b1e54aa015f5fc29befa38698795652995928cb0262937a2b6743c05e3d864736f6c63430008130033\n}\n",
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "60808060405234601757603a9081601d823930815050f35b600080fdfe600080fdfea26469706673582212208741b1e54aa015f5fc29befa38698795652995928cb0262937a2b6743c05e3d864736f6c63430008130033",
							"opcodes": "PUSH1 0x80 DUP1 PUSH1 0x40 MSTORE CALLVALUE PUSH1 0x17 JUMPI PUSH1 0x3A SWAP1 DUP2 PUSH1 0x1D DUP3 CODECOPY ADDRESS DUP2 POP POP RETURN JUMPDEST PUSH1 0x0 DUP1 REVERT INVALID PUSH1 0x0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 DUP8 COINBASE 0xB1 0xE5 0x4A LOG0 ISZERO CREATE2 0xFC 0x29 0xBE STATICCALL CODESIZE PUSH10 0x8795652995928CB02629 CALLDATACOPY LOG2 0xB6 PUSH21 0x3C05E3D864736F6C63430008130033000000000000 ",
							"sourceMap": "4982:2299:1:-:0;;;;;;;;;;;;;;;;;;;;;"
						},
						"deployedBytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "600080fdfea26469706673582212208741b1e54aa015f5fc29befa38698795652995928cb0262937a2b6743c05e3d864736f6c63430008130033",
							"opcodes": "PUSH1 0x0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 DUP8 COINBASE 0xB1 0xE5 0x4A LOG0 ISZERO CREATE2 0xFC 0x29 0xBE STATICCALL CODESIZE PUSH10 0x8795652995928CB02629 CALLDATACOPY LOG2 0xB6 PUSH21 0x3C05E3D864736F6C63430008130033000000000000 ",
							"sourceMap": "4982:2299:1:-:0;;"
						},
						"gasEstimates": {
							"creation": {
								"codeDepositCost": "11600",
								"executionCost": "infinite",
								"totalCost": "infinite"
							},
							"internal": {
								"calculateSqrtPriceX96(uint256)": "infinite",
								"calculateTicksFromPriceRange(uint160,uint160)": "infinite",
								"getSqrtPriceAtTick(int24)": "infinite",
								"getTickAtSqrtRatio(uint160)": "infinite",
								"sqrt(uint256)": "infinite",
								"sqrtPriceX96ToUint(uint160,uint8)": "infinite"
							}
						},
						"legacyAssembly": {
							".code": [
								{
									"begin": 4982,
									"end": 7281,
									"name": "PUSH",
									"source": 1,
									"value": "80"
								},
								{
									"begin": 4982,
									"end": 7281,
									"name": "DUP1",
									"source": 1
								},
								{
									"begin": 4982,
									"end": 7281,
									"name": "PUSH",
									"source": 1,
									"value": "40"
								},
								{
									"begin": 4982,
									"end": 7281,
									"name": "MSTORE",
									"source": 1
								},
								{
									"begin": 4982,
									"end": 7281,
									"name": "CALLVALUE",
									"source": 1
								},
								{
									"begin": 4982,
									"end": 7281,
									"name": "PUSH [tag]",
									"source": 1,
									"value": "1"
								},
								{
									"begin": 4982,
									"end": 7281,
									"name": "JUMPI",
									"source": 1
								},
								{
									"begin": 4982,
									"end": 7281,
									"name": "PUSH #[$]",
									"source": 1,
									"value": "0000000000000000000000000000000000000000000000000000000000000000"
								},
								{
									"begin": 4982,
									"end": 7281,
									"name": "SWAP1",
									"source": 1
								},
								{
									"begin": 4982,
									"end": 7281,
									"name": "DUP2",
									"source": 1
								},
								{
									"begin": 4982,
									"end": 7281,
									"name": "PUSH [$]",
									"source": 1,
									"value": "0000000000000000000000000000000000000000000000000000000000000000"
								},
								{
									"begin": 4982,
									"end": 7281,
									"name": "DUP3",
									"source": 1
								},
								{
									"begin": 4982,
									"end": 7281,
									"name": "CODECOPY",
									"source": 1
								},
								{
									"begin": 4982,
									"end": 7281,
									"name": "ADDRESS",
									"source": 1
								},
								{
									"begin": 4982,
									"end": 7281,
									"name": "DUP2",
									"source": 1
								},
								{
									"begin": 4982,
									"end": 7281,
									"name": "ASSIGNIMMUTABLE",
									"source": 1,
									"value": "library_deploy_address"
								},
								{
									"begin": 4982,
									"end": 7281,
									"name": "RETURN",
									"source": 1
								},
								{
									"begin": 4982,
									"end": 7281,
									"name": "tag",
									"source": 1,
									"value": "1"
								},
								{
									"begin": 4982,
									"end": 7281,
									"name": "JUMPDEST",
									"source": 1
								},
								{
									"begin": 4982,
									"end": 7281,
									"name": "PUSH",
									"source": 1,
									"value": "0"
								},
								{
									"begin": 4982,
									"end": 7281,
									"name": "DUP1",
									"source": 1
								},
								{
									"begin": 4982,
									"end": 7281,
									"name": "REVERT",
									"source": 1
								}
							],
							".data": {
								"0": {
									".auxdata": "a26469706673582212208741b1e54aa015f5fc29befa38698795652995928cb0262937a2b6743c05e3d864736f6c63430008130033",
									".code": [
										{
											"begin": 4982,
											"end": 7281,
											"name": "PUSH",
											"source": 1,
											"value": "0"
										},
										{
											"begin": 4982,
											"end": 7281,
											"name": "DUP1",
											"source": 1
										},
										{
											"begin": 4982,
											"end": 7281,
											"name": "REVERT",
											"source": 1
										}
									]
								}
							},
							"sourceList": [
								"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol",
								"contracts/lib/UniswapV3PriceCalculator.sol",
								"https://github.com/Uniswap/v3-core/blob/0.8/contracts/libraries/TickMath.sol",
								"#utility.yul"
							]
						},
						"methodIdentifiers": {}
					},
					"ewasm": {
						"wasm": ""
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/lib/UniswapV3PriceCalculator.sol\":\"UniswapV3PriceCalculator\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol\":{\"keccak256\":\"0x0ba8a9b95a956a4050749c0158e928398c447c91469682ca8a7cc7e77a7fe032\",\"license\":\"GPL-2.0-or-later\",\"urls\":[\"bzz-raw://186d3b528866065a5856f96d2aeec698efa99f8da913e9adf34f8cc296cc993d\",\"dweb:/ipfs/QmUAiMvtAQp8c9dy57bqJYzG7hkb1uChiPaQmt264skoqP\"]},\"contracts/lib/UniswapV3PriceCalculator.sol\":{\"keccak256\":\"0x50769d29efa35f0db307722bdede1b2c45f0c01277a9cb1255c75962f334baef\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://16042641a7b3401d6205e26581316bc881bc9c6917e93f09fe6c1f6e0a000bb0\",\"dweb:/ipfs/QmZBFVSBjXNC9KuoRz7yfJf6TmgfXEkJPx2fvmgGt2sPSw\"]},\"https://github.com/Uniswap/v3-core/blob/0.8/contracts/libraries/TickMath.sol\":{\"keccak256\":\"0x5c57de03a91cc2ec8939865dbbcb0197bb6c353b711075eefd8e0fca5e102129\",\"license\":\"GPL-2.0-or-later\",\"urls\":[\"bzz-raw://1e994c24fd891ef8a3f5dbf5eba42b34feaf05e0376a29f91322faa18054449c\",\"dweb:/ipfs/QmNdUJGUQxd1dPkMbnA5f5UNqakxRkQE5r7bTZJAuHeapS\"]}},\"version\":1}",
					"storageLayout": {
						"storage": [],
						"types": null
					},
					"userdoc": {
						"kind": "user",
						"methods": {},
						"version": 1
					}
				}
			},
			"https://github.com/Uniswap/v3-core/blob/0.8/contracts/libraries/TickMath.sol": {
				"TickMath": {
					"abi": [
						{
							"inputs": [],
							"name": "R",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "T",
							"type": "error"
						}
					],
					"devdoc": {
						"kind": "dev",
						"methods": {},
						"stateVariables": {
							"MAX_SQRT_RATIO": {
								"details": "The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)"
							},
							"MAX_TICK": {
								"details": "The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128"
							},
							"MIN_SQRT_RATIO": {
								"details": "The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)"
							},
							"MIN_TICK": {
								"details": "The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128"
							}
						},
						"title": "Math library for computing sqrt prices from ticks and vice versa",
						"version": 1
					},
					"evm": {
						"assembly": "    /* \"https://github.com/Uniswap/v3-core/blob/0.8/contracts/libraries/TickMath.sol\":305:9417  library TickMath {... */\n  0x80\n  dup1\n  0x40\n  mstore\n  jumpi(tag_1, callvalue)\n  dataSize(sub_0)\n  swap1\n  dup2\n  dataOffset(sub_0)\n  dup3\n  codecopy\n  address\n  dup2\n  assignImmutable(\"0xcd5a02d485074f67d63783a7acdae578618045c23ccf47fa4e3f1a01c11714ad\")\n  return\ntag_1:\n  0x00\n  dup1\n  revert\nstop\n\nsub_0: assembly {\n        /* \"https://github.com/Uniswap/v3-core/blob/0.8/contracts/libraries/TickMath.sol\":305:9417  library TickMath {... */\n      0x00\n      dup1\n      revert\n\n    auxdata: 0xa26469706673582212205761758a30300b52637af1a6fa6b998aec9afd2310681c52f329cc1c908ae08964736f6c63430008130033\n}\n",
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "60808060405234601757603a9081601d823930815050f35b600080fdfe600080fdfea26469706673582212205761758a30300b52637af1a6fa6b998aec9afd2310681c52f329cc1c908ae08964736f6c63430008130033",
							"opcodes": "PUSH1 0x80 DUP1 PUSH1 0x40 MSTORE CALLVALUE PUSH1 0x17 JUMPI PUSH1 0x3A SWAP1 DUP2 PUSH1 0x1D DUP3 CODECOPY ADDRESS DUP2 POP POP RETURN JUMPDEST PUSH1 0x0 DUP1 REVERT INVALID PUSH1 0x0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 JUMPI PUSH2 0x758A ADDRESS ADDRESS SIGNEXTEND MSTORE PUSH4 0x7AF1A6FA PUSH12 0x998AEC9AFD2310681C52F329 0xCC SHR SWAP1 DUP11 0xE0 DUP10 PUSH5 0x736F6C6343 STOP ADDMOD SGT STOP CALLER ",
							"sourceMap": "305:9112:2:-:0;;;;;;;;;;;;;;;;;;;;;"
						},
						"deployedBytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "600080fdfea26469706673582212205761758a30300b52637af1a6fa6b998aec9afd2310681c52f329cc1c908ae08964736f6c63430008130033",
							"opcodes": "PUSH1 0x0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 JUMPI PUSH2 0x758A ADDRESS ADDRESS SIGNEXTEND MSTORE PUSH4 0x7AF1A6FA PUSH12 0x998AEC9AFD2310681C52F329 0xCC SHR SWAP1 DUP11 0xE0 DUP10 PUSH5 0x736F6C6343 STOP ADDMOD SGT STOP CALLER ",
							"sourceMap": "305:9112:2:-:0;;"
						},
						"gasEstimates": {
							"creation": {
								"codeDepositCost": "11600",
								"executionCost": "infinite",
								"totalCost": "infinite"
							},
							"internal": {
								"getSqrtRatioAtTick(int24)": "infinite",
								"getTickAtSqrtRatio(uint160)": "infinite"
							}
						},
						"legacyAssembly": {
							".code": [
								{
									"begin": 305,
									"end": 9417,
									"name": "PUSH",
									"source": 2,
									"value": "80"
								},
								{
									"begin": 305,
									"end": 9417,
									"name": "DUP1",
									"source": 2
								},
								{
									"begin": 305,
									"end": 9417,
									"name": "PUSH",
									"source": 2,
									"value": "40"
								},
								{
									"begin": 305,
									"end": 9417,
									"name": "MSTORE",
									"source": 2
								},
								{
									"begin": 305,
									"end": 9417,
									"name": "CALLVALUE",
									"source": 2
								},
								{
									"begin": 305,
									"end": 9417,
									"name": "PUSH [tag]",
									"source": 2,
									"value": "1"
								},
								{
									"begin": 305,
									"end": 9417,
									"name": "JUMPI",
									"source": 2
								},
								{
									"begin": 305,
									"end": 9417,
									"name": "PUSH #[$]",
									"source": 2,
									"value": "0000000000000000000000000000000000000000000000000000000000000000"
								},
								{
									"begin": 305,
									"end": 9417,
									"name": "SWAP1",
									"source": 2
								},
								{
									"begin": 305,
									"end": 9417,
									"name": "DUP2",
									"source": 2
								},
								{
									"begin": 305,
									"end": 9417,
									"name": "PUSH [$]",
									"source": 2,
									"value": "0000000000000000000000000000000000000000000000000000000000000000"
								},
								{
									"begin": 305,
									"end": 9417,
									"name": "DUP3",
									"source": 2
								},
								{
									"begin": 305,
									"end": 9417,
									"name": "CODECOPY",
									"source": 2
								},
								{
									"begin": 305,
									"end": 9417,
									"name": "ADDRESS",
									"source": 2
								},
								{
									"begin": 305,
									"end": 9417,
									"name": "DUP2",
									"source": 2
								},
								{
									"begin": 305,
									"end": 9417,
									"name": "ASSIGNIMMUTABLE",
									"source": 2,
									"value": "library_deploy_address"
								},
								{
									"begin": 305,
									"end": 9417,
									"name": "RETURN",
									"source": 2
								},
								{
									"begin": 305,
									"end": 9417,
									"name": "tag",
									"source": 2,
									"value": "1"
								},
								{
									"begin": 305,
									"end": 9417,
									"name": "JUMPDEST",
									"source": 2
								},
								{
									"begin": 305,
									"end": 9417,
									"name": "PUSH",
									"source": 2,
									"value": "0"
								},
								{
									"begin": 305,
									"end": 9417,
									"name": "DUP1",
									"source": 2
								},
								{
									"begin": 305,
									"end": 9417,
									"name": "REVERT",
									"source": 2
								}
							],
							".data": {
								"0": {
									".auxdata": "a26469706673582212205761758a30300b52637af1a6fa6b998aec9afd2310681c52f329cc1c908ae08964736f6c63430008130033",
									".code": [
										{
											"begin": 305,
											"end": 9417,
											"name": "PUSH",
											"source": 2,
											"value": "0"
										},
										{
											"begin": 305,
											"end": 9417,
											"name": "DUP1",
											"source": 2
										},
										{
											"begin": 305,
											"end": 9417,
											"name": "REVERT",
											"source": 2
										}
									]
								}
							},
							"sourceList": [
								"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol",
								"contracts/lib/UniswapV3PriceCalculator.sol",
								"https://github.com/Uniswap/v3-core/blob/0.8/contracts/libraries/TickMath.sol",
								"#utility.yul"
							]
						},
						"methodIdentifiers": {}
					},
					"ewasm": {
						"wasm": ""
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"R\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"T\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"MAX_SQRT_RATIO\":{\"details\":\"The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\"},\"MAX_TICK\":{\"details\":\"The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\"},\"MIN_SQRT_RATIO\":{\"details\":\"The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\"},\"MIN_TICK\":{\"details\":\"The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\"}},\"title\":\"Math library for computing sqrt prices from ticks and vice versa\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports prices between 2**-128 and 2**128\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"https://github.com/Uniswap/v3-core/blob/0.8/contracts/libraries/TickMath.sol\":\"TickMath\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"https://github.com/Uniswap/v3-core/blob/0.8/contracts/libraries/TickMath.sol\":{\"keccak256\":\"0x5c57de03a91cc2ec8939865dbbcb0197bb6c353b711075eefd8e0fca5e102129\",\"license\":\"GPL-2.0-or-later\",\"urls\":[\"bzz-raw://1e994c24fd891ef8a3f5dbf5eba42b34feaf05e0376a29f91322faa18054449c\",\"dweb:/ipfs/QmNdUJGUQxd1dPkMbnA5f5UNqakxRkQE5r7bTZJAuHeapS\"]}},\"version\":1}",
					"storageLayout": {
						"storage": [],
						"types": null
					},
					"userdoc": {
						"kind": "user",
						"methods": {},
						"notice": "Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports prices between 2**-128 and 2**128",
						"version": 1
					}
				}
			}
		},
		"sources": {
			"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol": {
				"id": 0
			},
			"contracts/lib/UniswapV3PriceCalculator.sol": {
				"id": 1
			},
			"https://github.com/Uniswap/v3-core/blob/0.8/contracts/libraries/TickMath.sol": {
				"id": 2
			}
		}
	}
}